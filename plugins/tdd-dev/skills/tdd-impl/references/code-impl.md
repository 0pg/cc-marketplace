# Code Implementation Protocol

Red-Green-Refactor 사이클을 따라 테스트 코드와 구현 코드를 작성합니다.

## Red-Green-Refactor Cycle

```
┌─────────────────────────────────────────────────────────┐
│                    RED PHASE                            │
│                                                         │
│  1. 테스트 코드 작성                                    │
│  2. 테스트 실행                                         │
│  3. 실패 확인 (컴파일 에러 또는 assertion 실패)        │
│                                                         │
│  ⚠️ 반드시 실패해야 함 - 실패하지 않으면 문제 있음     │
└────────────────────────────┬────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────┐
│                   GREEN PHASE                           │
│                                                         │
│  1. 테스트 통과하는 최소 코드 작성                      │
│  2. "작동하는 가장 간단한 것"                           │
│  3. 테스트 실행                                         │
│  4. 통과 확인                                           │
│                                                         │
│  ⚠️ 과도한 구현 금지 - 테스트가 요구하는 것만          │
└────────────────────────────┬────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────┐
│                  REFACTOR PHASE                         │
│                                                         │
│  1. 코드 품질 개선 (중복 제거, 명확성 향상)            │
│  2. 테스트 실행                                         │
│  3. 여전히 통과 확인                                    │
│                                                         │
│  ⚠️ 동작 변경 없이 구조만 개선                         │
└────────────────────────────┬────────────────────────────┘
                             ↓
                    다음 테스트 케이스
```

## Phase 상세

### RED Phase: 테스트 작성

**목표**: 실패하는 테스트 작성

```markdown
1. 테스트 명세 확인
   - 테스트 케이스 ID
   - Given-When-Then 시나리오
   - Mock 의존성

2. 테스트 코드 작성
   - 테스트 설정 (Arrange/Given)
   - 실행 (Act/When)
   - 검증 (Assert/Then)

3. 테스트 실행 및 실패 확인
   - 컴파일 에러: 대상 코드가 없음 → 정상
   - 런타임 에러: 구현이 없음 → 정상
   - 테스트 통과: 문제 있음! 테스트 검토 필요
```

**체크리스트:**
- [ ] 테스트가 명확한 하나의 동작을 검증하는가?
- [ ] 테스트 이름이 의도를 표현하는가?
- [ ] Mock이 인터페이스를 명확히 정의하는가?
- [ ] 테스트가 실패하는가?

### GREEN Phase: 최소 구현

**목표**: 테스트를 통과하는 가장 간단한 코드

```markdown
1. 인터페이스 구현
   - Mock에서 정의한 시그니처 그대로
   - 반환 타입 정확히 일치

2. 최소 로직 작성
   - 하드코딩도 OK (나중에 리팩토링)
   - 테스트가 요구하는 것만 구현

3. 테스트 실행 및 통과 확인
   - 모든 관련 테스트 통과
   - 기존 테스트도 여전히 통과
```

**체크리스트:**
- [ ] 테스트가 요구하지 않는 것을 구현하지 않았는가?
- [ ] 가장 간단한 방법으로 구현했는가?
- [ ] 모든 테스트가 통과하는가?

### REFACTOR Phase: 코드 개선

**목표**: 동작 유지하며 구조 개선

```markdown
1. 코드 스멜 식별
   - 중복 코드
   - 긴 메서드
   - 불명확한 이름
   - 과도한 복잡성

2. 리팩토링 적용
   - 한 번에 하나씩
   - 각 변경 후 테스트 실행

3. 테스트 유지 확인
   - 모든 테스트 여전히 통과
   - 테스트 코드도 리팩토링 가능
```

**일반적인 리팩토링:**
- Extract Method: 긴 메서드 분리
- Rename: 의도를 명확히 하는 이름
- Remove Duplication: 중복 제거
- Simplify Conditionals: 조건문 단순화

**체크리스트:**
- [ ] 동작이 변경되지 않았는가?
- [ ] 코드가 더 읽기 쉬워졌는가?
- [ ] 모든 테스트가 여전히 통과하는가?

## 구현 순서

### Bottom-Up 구현 (인터페이스는 Top-Down으로 발견)

테스트 설계는 Top-Down으로 했지만, 구현은 Bottom-Up으로:

```
1. 가장 하위 레벨 Unit Test 구현
   → 의존성 없는 순수 컴포넌트

2. 중간 레벨 Integration Test 구현
   → 하위 컴포넌트 조합

3. 최상위 Acceptance Test 구현
   → 전체 시스템 통합
```

**이유:**
- 하위 컴포넌트가 있어야 상위 테스트의 Mock을 실제로 교체 가능
- 점진적으로 시스템 완성

## 안티패턴

### 1. 테스트 없이 구현
```
❌ 코드 먼저, 테스트 나중
✅ 테스트 먼저, 코드 나중
```

### 2. 과도한 구현
```
❌ "나중에 필요할 것 같아서" 미리 구현
✅ 테스트가 요구하는 것만 구현
```

### 3. 리팩토링 건너뛰기
```
❌ GREEN 후 바로 다음 테스트
✅ GREEN 후 반드시 리팩토링 검토
```

### 4. 여러 테스트 동시 작성
```
❌ 테스트 10개 작성 후 한꺼번에 구현
✅ 테스트 1개 → 구현 → 테스트 1개 → 구현
```

### 5. 실패하지 않는 테스트
```
❌ 처음부터 통과하는 테스트 (의미 없음)
✅ 반드시 실패 후 구현으로 통과
```

## 검증 명령

각 Phase 후 테스트 실행:

```bash
# 언어/프레임워크별 테스트 명령
# 예시:
npm test           # JavaScript/TypeScript
pytest             # Python
cargo test         # Rust
go test ./...      # Go
mvn test           # Java (Maven)
```

## 완료 기준

- [ ] 모든 테스트 케이스 구현됨
- [ ] 모든 테스트 통과
- [ ] 코드 리팩토링 완료
- [ ] 테스트 커버리지 적정 수준 (권장 80%+)
