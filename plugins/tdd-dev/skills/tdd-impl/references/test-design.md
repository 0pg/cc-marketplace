# Test Design Protocol

Top-Down 방식으로 테스트를 설계하고, Mock을 통해 인터페이스를 발견합니다.

## 핵심 원칙

**테스트가 인터페이스를 정의한다**

- 상위 테스트 작성 시 → 필요한 협력 객체 발견
- Mock으로 협력 객체 대체 → 인터페이스 계약 정의
- Mock의 메서드 시그니처 = 실제 인터페이스
- 하위 레벨에서 Mock을 실제 구현으로 교체

## 테스트 레벨

### Level 1: Acceptance Test (상위)

**목적**: 전체 기능의 동작 정의

- 사용자 관점의 시나리오
- End-to-End 동작 검증
- 비즈니스 요구사항과 직접 매핑

**설계 포인트:**
- Given-When-Then 패턴 활용
- 외부 의존성은 Mock으로 대체
- Mock이 드러내는 인터페이스 기록

### Level 2: Integration Test (중간)

**목적**: 컴포넌트 간 통신 인터페이스 정의

- 컴포넌트 경계의 동작 검증
- 데이터 변환/전달 검증
- 에러 전파 검증

**설계 포인트:**
- 상위에서 발견된 인터페이스 구체화
- 하위 의존성은 Mock으로 대체
- 새로운 하위 인터페이스 발견

### Level 3: Unit Test (하위)

**목적**: 개별 객체/함수의 인터페이스 정의

- 단일 책임 검증
- 경계 조건 검증
- 에러 처리 검증

**설계 포인트:**
- 상위에서 정의된 인터페이스 준수
- 외부 의존성 최소화
- 순수 함수 지향

## 인터페이스 발견 프로세스

```
┌─────────────────────────────────────────────────────────┐
│ Step 1: 요구사항에서 최상위 테스트 케이스 도출         │
│                                                         │
│ 요구사항: "사용자가 로그인하면 대시보드를 보여준다"    │
│                     ↓                                   │
│ 테스트: "유효한 자격증명으로 로그인하면 대시보드 반환" │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ Step 2: 테스트 작성 시 필요한 협력 객체 식별           │
│                                                         │
│ LoginController 테스트 작성                             │
│   → AuthService 필요 (Mock)                             │
│   → UserRepository 필요 (Mock)                          │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ Step 3: Mock 메서드 시그니처 = 인터페이스 계약         │
│                                                         │
│ mockAuthService.authenticate(credentials) → AuthResult │
│ mockUserRepository.findById(userId) → User             │
│                                                         │
│ 이 시그니처가 실제 인터페이스가 됨                     │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│ Step 4: 하위 레벨 테스트에서 Mock을 구체화             │
│                                                         │
│ AuthService 테스트 작성                                 │
│   → TokenGenerator 필요 (Mock)                          │
│   → PasswordHasher 필요 (Mock)                          │
│                                                         │
│ 같은 과정 반복 (재귀적)                                 │
└─────────────────────────────────────────────────────────┘
```

## 테스트 케이스 도출 기법

### 1. 등가 분할 (Equivalence Partitioning)

입력 도메인을 동등한 클래스로 분할하여 대표값 테스트

```
예: 나이 입력
- 유효: 0-150 → 대표값: 25
- 무효(음수): < 0 → 대표값: -1
- 무효(초과): > 150 → 대표값: 200
```

### 2. 경계값 분석 (Boundary Value Analysis)

경계 지점과 그 주변값 테스트

```
예: 0-100 범위
- 경계값: -1, 0, 1, 99, 100, 101
```

### 3. 상태 전이 (State Transition)

상태 변화에 따른 동작 테스트

```
예: 주문 상태
- Created → Paid → Shipped → Delivered
- Created → Cancelled
- Paid → Refunded
```

### 4. 결정 테이블 (Decision Table)

조건 조합에 따른 결과 테스트

```
예: 할인 적용
| VIP | 쿠폰 | 첫구매 | 할인율 |
|-----|------|--------|--------|
| Y   | Y    | -      | 30%    |
| Y   | N    | -      | 20%    |
| N   | Y    | Y      | 15%    |
| N   | Y    | N      | 10%    |
| N   | N    | Y      | 5%     |
| N   | N    | N      | 0%     |
```

## 테스트 명세 문서화

### 템플릿

```markdown
## 테스트 케이스: [케이스 ID]

### 대상
- 컴포넌트: [테스트 대상]
- 메서드/기능: [테스트할 기능]

### 시나리오
- Given: [사전 조건]
- When: [실행 동작]
- Then: [기대 결과]

### Mock 의존성
- [Mock 객체]: [인터페이스 시그니처]

### 경계 조건
- [경계 케이스 목록]

### 에러 케이스
- [에러 상황]: [기대 동작]
```

## 산출물

1. **테스트 케이스 목록**: 레벨별 테스트 케이스
2. **인터페이스 정의**: Mock에서 발견된 인터페이스
3. **테스트 우선순위**: 구현 순서 결정
