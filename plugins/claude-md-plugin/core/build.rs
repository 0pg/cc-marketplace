//! Build script for claude-md-core
//!
//! Reads schema rules from YAML (Single Source of Truth) and generates
//! Rust constants at compile time.

use serde::Deserialize;
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::Path;

/// Section definition in schema-rules.yaml
#[derive(Debug, Deserialize)]
struct SectionDef {
    name: String,
    required: bool,
    #[serde(default)]
    condition: String,
    #[serde(default)]
    allow_none: bool,
    #[serde(default)]
    required_subsections: Option<Vec<String>>,
}

/// Forbidden reference pattern in schema-rules.yaml
#[derive(Debug, Deserialize)]
struct ForbiddenPattern {
    pattern: String,
    description: String,
}

/// Reference rules in schema-rules.yaml
#[derive(Debug, Deserialize)]
struct ReferenceRules {
    #[serde(default)]
    forbidden_patterns: Vec<ForbiddenPattern>,
    #[allow(dead_code)]
    #[serde(default)]
    allowed_patterns: Vec<ForbiddenPattern>,
}

/// Convention rules in schema-rules.yaml
#[derive(Debug, Deserialize)]
struct ConventionRules {
    module_root_markers: Vec<String>,
}

/// Schema rules structure
#[derive(Debug, Deserialize)]
struct SchemaRules {
    version: String,
    #[allow(dead_code)]
    description: String,
    sections: HashMap<String, SectionDef>,
    #[serde(default)]
    convention_rules: Option<ConventionRules>,
    #[serde(default)]
    reference_rules: Option<ReferenceRules>,
}

fn main() {
    // Path to schema rules YAML (relative to core/ directory)
    let schema_path = "../skills/schema-validate/references/schema-rules.yaml";

    // Tell Cargo to rerun if the schema file changes
    println!("cargo:rerun-if-changed={}", schema_path);

    // Read and parse the YAML file
    let yaml_content = fs::read_to_string(schema_path).unwrap_or_else(|e| {
        panic!(
            "Failed to read schema-rules.yaml at '{}': {}. \
             Make sure the file exists at plugins/claude-md-plugin/skills/schema-validate/references/schema-rules.yaml",
            schema_path, e
        )
    });

    let rules: SchemaRules = serde_yaml::from_str(&yaml_content).unwrap_or_else(|e| {
        panic!("Failed to parse schema-rules.yaml: {}", e)
    });

    // Extract required sections (where required=true and condition="always")
    let mut required_sections: Vec<&str> = rules
        .sections
        .values()
        .filter(|s| s.required && s.condition == "always")
        .map(|s| s.name.as_str())
        .collect();

    // Sort for consistent ordering
    required_sections.sort();

    // Extract sections that allow "None" as valid content
    let mut allow_none_sections: Vec<&str> = rules
        .sections
        .values()
        .filter(|s| s.allow_none)
        .map(|s| s.name.as_str())
        .collect();

    allow_none_sections.sort();

    // Extract required subsections for Project Convention
    let project_convention_subsections: Vec<&str> = rules
        .sections
        .get("project_convention")
        .and_then(|s| s.required_subsections.as_ref())
        .map(|subs| subs.iter().map(|s| s.as_str()).collect())
        .unwrap_or_default();

    // Extract required subsections for Code Convention
    let code_convention_subsections: Vec<&str> = rules
        .sections
        .get("code_convention")
        .and_then(|s| s.required_subsections.as_ref())
        .map(|subs| subs.iter().map(|s| s.as_str()).collect())
        .unwrap_or_default();

    // Extract forbidden reference patterns
    let forbidden_ref_patterns: Vec<(&str, &str)> = rules
        .reference_rules
        .as_ref()
        .map(|rr| {
            rr.forbidden_patterns
                .iter()
                .map(|p| (p.pattern.as_str(), p.description.as_str()))
                .collect()
        })
        .unwrap_or_default();

    // Extract module root markers
    let module_root_markers: Vec<&str> = rules
        .convention_rules
        .as_ref()
        .map(|cr| cr.module_root_markers.iter().map(|s| s.as_str()).collect())
        .unwrap_or_default();

    // Generate Rust code
    let code = format!(
        r#"// Auto-generated by build.rs from schema-rules.yaml
// DO NOT EDIT MANUALLY - Edit skills/schema-validate/references/schema-rules.yaml instead

/// Schema rules version
#[allow(dead_code)]
pub const SCHEMA_VERSION: &str = "{}";

/// Required sections in CLAUDE.md (must always be present)
#[allow(dead_code)]
pub const REQUIRED_SECTIONS: &[&str] = &{:?};

/// Sections that allow "None" as valid content
#[allow(dead_code)]
pub const ALLOW_NONE_SECTIONS: &[&str] = &{:?};

/// Required subsections for Project Convention section
#[allow(dead_code)]
pub const PROJECT_CONVENTION_REQUIRED_SUBSECTIONS: &[&str] = &{:?};

/// Required subsections for Code Convention section
#[allow(dead_code)]
pub const CODE_CONVENTION_REQUIRED_SUBSECTIONS: &[&str] = &{:?};

/// File markers that identify a module root directory
#[allow(dead_code)]
pub const MODULE_ROOT_MARKERS: &[&str] = &{:?};

/// Forbidden reference patterns for Dependencies validation (regex_pattern, description)
#[allow(dead_code)]
pub const FORBIDDEN_REFERENCE_PATTERNS: &[(&str, &str)] = &{:?};
"#,
        rules.version,
        required_sections,
        allow_none_sections,
        project_convention_subsections,
        code_convention_subsections,
        module_root_markers,
        forbidden_ref_patterns
    );

    // Write to OUT_DIR
    let out_dir = env::var("OUT_DIR").expect("OUT_DIR not set");
    let dest_path = Path::new(&out_dir).join("schema_rules.rs");

    fs::write(&dest_path, code).unwrap_or_else(|e| {
        panic!("Failed to write generated code to {:?}: {}", dest_path, e)
    });

    println!("cargo:warning=Generated schema_rules.rs with {} required sections", required_sections.len());
}
