# Project Context Store Plugin

## 목적

**코드를 삭제해도 Context만으로 도메인을 파악하여 동일한 코드를 작성할 수 있도록 하는 것.**

이것이 플러그인의 유일한 존재 이유입니다.

## 핵심 개념: 확률적 재현가능성

### 검증 질문
"이 context file 기반으로 디렉토리의 코드를 동일하게 작성할 수 있었을까?"

### 성공 기준
"적당히 많은 횟수만큼 시도했을 때 동일하게 나올 수 있다"

```
기존: 매번 똑같은 코드가 나와야 함 (결정론적)
변경: 여러 번 시도하면 동일한 코드가 나올 수 있을 정도의 정보 (확률적)
```

### 문서의 역할
- **아님**: "이 문서로 코드를 재현해라" (재현 매뉴얼)
- **맞음**: "이 문서로 도메인을 파악하고, 그 이해로 코드를 작성해라" (도메인 이해 문서)

### Context란?

도메인을 이해하고 코드를 작성하는데 필요하지만 **코드 자체에서 읽어낼 수 없는 정보**:

| 구분 | 예시 | 왜 필요한가 |
|------|------|------------|
| 도메인 개념 | Session, Token | 비즈니스 용어의 정의와 의미 |
| 비즈니스 규칙 | `if age < 19:` | "왜 19인가?" - 법규, 정책, 비즈니스 요구사항 |
| 도메인 상수 | `TIMEOUT = 30` | "왜 30인가?" - 스펙, 실험 결과, 외부 제약 등 |
| 설계 결정 | "왜 이 라이브러리를 선택했나" | 대안 검토 결과, 트레이드오프 |
| 외부 연동 | API 엔드포인트, 프로토콜 | 스펙 문서 참조, 버전 정보 |
| Tribal Knowledge | "이렇게 하면 안 되는 이유" | 과거 실패 경험, 숨겨진 제약 |

### Context가 아닌 것

코드에서 직접 읽어낼 수 있는 정보:
- 함수/클래스 시그니처 (코드가 정의)
- 타입 정보 (코드가 정의)
- 제어 흐름 자체 (코드가 보여줌)
- 일반적인 프로그래밍 패턴 (상식)
- 파일 목록 (코드베이스가 보여줌)

## 아키텍처

```
Skills (사용자 진입점)          Agents (Task로 실행)
├── context-generate ────────→ context-generator (재귀)
├── context-update ──────────→ context-generator
└── context-validate ────────→ drift-validator (병렬)
                              → reproducibility-validator (병렬)
                              → 결과 취합 및 통합 보고
```

### Skill vs Agent 관계

| 구분 | 역할 |
|------|------|
| Skill | 사용자 진입점, 루트에서 Agent 시작 |
| Agent | 재귀적 디렉토리 탐색, 하위 Task 생성, CLAUDE.md 작성 |

## 워크플로우 (재귀 패턴)

```
Skill → 루트 디렉토리에서 Agent 시작
Agent → 1. 하위 디렉토리 탐지 (소스 코드 존재 여부)
        2. 소스 코드 있는 하위 디렉토리에 Task 먼저 트리거 (병렬)
        3. 현재 디렉토리 분석 및 CLAUDE.md 생성
        4. 모듈 구조 요약 포함 (하위 디렉토리 역할 테이블)
```

1. 사용자가 `/context-generate` 호출
2. Skill이 루트 디렉토리에서 context-generator Agent 시작
3. Agent가 하위 디렉토리 탐지 후 재귀적으로 Task 생성 (병렬)
4. 각 Agent가 현재 디렉토리 분석, 사용자 질의, CLAUDE.md 작성
5. 상위 CLAUDE.md에 하위 모듈 구조 요약 포함
6. 결과 수집 및 보고

**재귀 패턴의 장점:**
- Skill이 전체 디렉토리 구조를 미리 파악할 필요 없음
- Agent가 트리 구조를 자연스럽게 탐색
- 각 Agent가 자신의 컨텍스트에만 집중
- 실패 격리 (한 브랜치 실패해도 다른 브랜치 계속)

## 검증 방식 비교

`/context-validate` skill이 두 가지 검증을 통합하여 수행합니다:

| 구분 | Drift 검증 | 재현성 검증 |
|------|-----------|------------|
| Agent | drift-validator | reproducibility-validator |
| 목적 | 코드-문서 **불일치** 탐지 | **확률적 재현 가능성** 검증 |
| 방법 | 문서 내용과 코드 직접 비교 | AI가 문서만 보고 도메인 이해 후 코드 구조 예측 |
| 질문 | "문서와 코드가 일치하는가?" | "문서로 도메인을 파악하여 코드를 작성할 수 있는가?" |
| 탐지 대상 | 오래된 값, 삭제된 항목, 새 항목 | 도메인 컨텍스트 누락, 비즈니스 규칙 설명 부족 |

두 에이전트는 **병렬로 실행**되며, 결과가 통합 보고서로 취합됩니다.

## 성공 기준

**테스트**: 코드를 모두 삭제하고 CLAUDE.md만 주었을 때, Claude가 여러 번 시도하면 동일한 코드를 작성할 수 있어야 함.

이를 검증하는 것이 `/context-validate`의 목적입니다.

## 파일 구조

```
plugins/project-context-store/
├── .claude-plugin/
│   ├── plugin.json          # 플러그인 매니페스트
│   └── marketplace.json     # 마켓플레이스 메타데이터
├── CLAUDE.md                # 이 파일 (개발 가이드)
├── README.md                # 사용자 문서
├── skills/
│   ├── context-generate/    # 컨텍스트 생성 (재귀적 CLAUDE.md 생성)
│   ├── context-update/      # 변경 감지 및 업데이트
│   └── context-validate/    # 통합 검증 (Drift + 재현성)
├── agents/
│   ├── context-generator.md      # 분석/문서화 에이전트 (재귀)
│   ├── drift-validator.md        # Drift 검증 에이전트 (코드-문서 일치)
│   └── reproducibility-validator.md # 재현성 검증 에이전트
├── hooks/
│   ├── hooks.json           # 변경 감지 훅
│   └── detect-code-changes.md
└── templates/
    └── claude-md-template.md # CLAUDE.md 구조 템플릿
```

## 개발 원칙

1. **추측 금지**: 확신 없으면 반드시 사용자에게 질문
2. **격리**: 각 에이전트는 자신의 담당 디렉토리만 처리
3. **확률적 재현가능성**: 생성된 문서로 도메인을 이해하여 코드 작성 가능해야 함
